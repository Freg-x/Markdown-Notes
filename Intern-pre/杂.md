作者：starrring
链接：https://www.nowcoder.com/discuss/183113?type=post&order=time&pos=&page=1
来源：牛客网



**网易：**

**C++方面的问题：**

**1、虚函数的作用以及实现原理**











**2、overload以及overwrite的区别**

1）覆盖override：派生类函数覆盖基类函数, 基类函数必须有virtual 关键字。

2）重载overload：可以将语义、功能相似的几个函数用同一个名字表示，但参数不同（包括类型、顺序不同），即函数重载。

3）重写overwrite：派生类的函数屏蔽了与其同名的基类函数



3、**一个空的class类里有什么**

1）构造函数

2）拷贝构造函数

3）析构函数

4）赋值运算符重载

5）取地址操作符重载

6）被const修饰的取地址操作符重载

**4、struct S{char a; int b; static long c; }请问sizeof(S)是多少？为什么，有什么好处？**

涉及到内存对齐机制

静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员．但是它不影响类的大小，不管这个类实际产生了多少实例，还是派生了多少新的类，静态成员数据在类中永远只有一个实体存在。

而类的非静态数据成员只有被实例化的时候，他们才存在．但是类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在．可以这么说，类的静态数据成员是一种特殊的全局变量．

所以该类的size为：32位系统上，是8个字节，字节对齐，方便寻址操作（当CPU试图读取的数值没有正确的对齐时，CPU可以执行两种操作之一：产生一个异常条件；执行多次对齐的内存访问，以便读取完整的未对齐数据，若多次执行内存访问，应用程序的运行速度就会慢）

**5、STL中有什么类**

1）vector: 内部实现是数组，一段连续的内存。

2）list， 内部实现是双链表

3）deque 内部实现是内存块的链表。

4）string： 连续的内存

5）set，map： 红黑树(平衡二叉树的一种)

6）hash_map, hash_set 用哈希表(散列表)来实现。

7）stack: 用vector或者是deque来实现

8）queue,用deque实现

**6、const的作用，宏定义与const的区别**

**7、定义一个class，编译器的内存分配**

1）类的大小为类的非静态成员数据的类型大小之和，也 就是说静态成员数据不作考虑。

2）普通成员函数与sizeof无关。

3）虚函数由于要维护在虚函数表，所以要占据一个指针大小，也就是4字节。

4）类的总大小也遵守类似class字节对齐的，调整规则。

12、函数重载，模板template，用法和区别

13、多态、虚函数、智能指针

14、指针与引用的区别

15、还有一些C++库函数的实现。

16、inline关键字是做什么用的？inline关键字在什么情况下会展开失败？

inline类似于宏替换，使用函数体替换调用处的函数名，省去了调用函数的开销，增快了代码的执行效率。但是又不是宏替换，inline函数是真正的函数，编译器会考虑语义。

函数体内代码长度过大，包含复杂的结构控制语句（while，switch）,包含内联函数本身，含有递归均会导致展开失败。

17、sizeof一个空类是多大？为什么？编译器为什么这么做？如果添加一个构造函数和析构函数呢？

1个字节，任何一个实例在内存中都占有一定的空间，也就有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址

调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数而在实例内添加任何额外信息

18、在这个类中添加一个virtual函数后再sizeof，这时是多大？为什么？

C++编译器一旦发现一个类型有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，在32位系统中，一个指针占4个字节，因此sizeof得到4个字节

19、将这个类再virtual继承一个其它的空类，这是多大？为什么？

12个字节，这个类本身大小为4个字节，空类的大小为1个字节，加上虚基类偏移量表指针4个指针，又因为要指针对齐（4个字节），故一起12个字节（虚基类偏移量表不占用类的存储空间，表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员）

20、类有哪几种权限，分别说明？

private，protected，public

21、class A :class B{},A是私有继承还是？ 私有继承是做什么用的？

默认是私有继承，私有继承后，基类所有成员在派生类中为private成员。私有基类的public成员和protected成员在私有派生类中的访问属性相当于派生类中的私有成员，即派生类的成员函数能访问它们，而在派生类外不能访问它们。私有基类的私有成员在派生类中称为不可访问的成员，只有基类的成员函数可以引用它们。

22、子类的虚函数中能不能调用父类的虚函数，为什么？

23、有纯虚函数的类能不能实例化？

不能，有纯虚函数的类是抽象类，只能被继承，不能实例化。包含纯虚函是的类派生出来的类都必须重写这个纯虚函数

24、C++多态有哪几种？

静态多态（函数重载和运算符重载），是在编译的时候，就确定调用函数的类型；动态多态（虚函数实现），在运行的时候，才能确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。

a.应用形式上：静多态是发散式的，让相同的实现代码应用于不同的场合。动多态是收敛式的，让不同的实现代码应用于相同的场合。

b.思维方式上：静多态是泛型式编程风格，它看重的是算法的普适性；动多态是对象式编程风格，它看重的是接口和实现的分离度。

25、C++是怎么实现动态多态的？

虚函数表和指向虚函数表的vptr指针。这个需要注意vptr指针的分布初始化问题，是在构造函数之后，初始化列表和函数体之前完成的。

26、对象中的VPTR指针什么时候被初始化？

Vptr指针初始化的过程：

a.对象在创建的时,由编译器对VPTR指针进行初始化

b.只有当对象的构造完全结束后VPTR的指向才最终确定

c.父类对象的VPTR指向父类虚函数表

d.子类对象的VPTR指向子类虚函数表

当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针（也可以认为Vptr指针是属于父类的成员，所以在子类中重写虚函数的时候virtual关键字可以省略，因为编译器会识别父类有虚函数，然后就会生成Vptr指针变量），该指针会指向父类的虚函数表；然后再调用子类的构造函数，此时Vptr又被赋值指向子类的虚函数表。

（执行父类的构造函数的时候Vptr指针指向的是父类的虚函数表，所以只能执行父类的虚函数）

上面的过程是Vptr指针初始化的过程。

这是因为这个原因，在构造函数中调用虚函数不能实现多态。

27、简要说说C++的静态多态?

函数重载和运算符重载，见上上题。

28、C++编译后的函数符号和C语言编译后的函数符号有哪些区别？为什么

C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为void func(int x,int y)。该函数被C编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。 C++中提供了C连接交换指定符号 extern "C" 解决名字匹配问题。

29、C++智能指针有哪些？auto_ptr和share_ptr有什么区别？他们有什么作用？

STL一共给我们提供了四种智能指针：auto_ptr , unique_ptr , shared_ptr和weak_ptr

auto_ptr的初衷是用来实现智能指针的，实现内存的自动回收。那么如何实现智能的呢？智能指针最基本的概念是引用计数，也就是智能指针内部有一个计数器，记录了当前内存资源到底有多少指针在引用（可以引用这个资源），当新增加一个可以访问这个资源的引用时，计数器会加1，反之会减去1，当计数器为0时，智能指针会自动释放它所管理的资源。手动申请，自动释放，就是智能的体现。

30、有序vector和list二分查找的时间复杂度分别是多少？

vector的二分相当于数组的二分，时间复杂度是O(logn)，list没办法二分，只能每次从头到尾找，时间复杂度为O(n)。

31、vector自动扩容是按什么大小进行的？

缺省的情况下vector的扩展机制是按2倍大小进行扩展的。在整个大小扩展的过程中，主要的步骤是：a.为需要的新容量分配足够的内存；b.将元素从原来的内存拷贝到新内存中去；c.销毁原来内存中的元素；d.归还原来的内存。

32、构造函数可以调用虚函数吗？语法上通过吗？语义上可以通过吗？

语法可以通过，但是语义不对。

总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug，因此c++不让你走这条路。
33、析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？

1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
34、c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？（对指针，返回NULL.对引用，抛出bad_cast异常）

对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针；

对引用进行dynamic_cast，失败抛出一个异常，成功返回正常cast后的对象引用。

35、拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？

1) 一个对象以值传递的方式传入函数体； 2) 一个对象以值传递的方式从函数返回； 3) 一个对象需要通过另外一个对象进行初始化；

36、c++里面的虚函数的原理和实现

37、平时开发当中多态用的多么？

命令模式

38、 多态的开销有多大？

39、菱形继承的虚函数的开销说一下

40、malloc是如何实现的？

malloc基本的实现原理就是维护一个内存空闲链表，当申请内存空间时，搜索内存空闲链表，找到适配的空闲内存空间，然后将空间分割成两个内存块，一个变成分配块，一个变成新的空闲块。如果没有搜索到，那么就会用sbrk()才推进brk指针来申请内存空间。

41、如果物理内存是2G 如果mallco 4G可以么？会有什么问题？

malloc的实现与物理内存自然是无关的，分配到的内存只是虚拟内存，而且只是虚拟内存的页号，代表这块空间进程可以用，实际上还没有分配到实际的物理页面。

42、能说一下STL几种容器么说一下这些容器的对比

43、vector和list的使用场景区别

1 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector

2 如果你需要大量的插入和删除，而不关心随即存取，则应使用list

3 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque

44、C++析构和构造的顺序，为什么析构函数最好是虚函数

1）构造函数顺序：先基类、再数据成员中是类对象的构造函数、最后派生类构造函数的函数体

2）析构函数顺序：与构造函数相反

3）析构函数最好是虚函数：若派生类有一个指向动态内存分配的数据成员，而又将基类的指针指向派生类对象，同时基类的析构函数又不是虚函数的话，编译器就实施静态绑定，释放基类指针所指对象的空间时候只执行基类的析构函数，不执行派生类的析构函数，那派生类动态分配的数据成员所申请的空间就不能被释放，这就造成了内存泄漏。

45、虚函数和虚函数表

1）虚函数：声明成员函数为虚函数以后，就可以实现动态绑定，也就是基类指针可以指向派生类对象，实现相同函数名的派生类的特定行为

2）虚函数表：就是用来运行时查询，帮助系统将某一函数名绑定到虚成员函数表中特定入口地址



46、智能指针了解么，全部都讲一下怎么用，会出现什么问题

47、知道c++11新特性吗，知道智能指针吗，知道智能指针实现吗，来你给我马上实现一个智能指针【要求写出成员和构造函数析构函数】

48、C 简单问了下static，然后就转战别的基础了。





**数据结构和算法：**

\1.   向量和队列有什么区别

1）向量：能高效的进行随机存取，时间复杂度为o(1); 在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。

2）队列：能高效的进行随机存取，时间复杂度为o(1);在内部方便的进行头尾部的插入和删除操作，时间复杂度为o(n)。

\2.   向量和队列的实现原理是什么（当时我说可以用链表以及数组，面试官就问我链表如何实现向量的随机访问，然后我就意识到链表不能实现向量了，因为不能实现随机访问，这个问题我答地比较糟糕）

1）向量: vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

2）队列:deque的元素数据采用分块的线性结构进行存储，deque分成若干线性存储块，称为deque块。块的大小一般为512个字节，元素的数据类型所占用的字节数，决定了每个deque块可容纳的元素个数。

所有的deque块使用一个Map块进行管理，每个Map数据项记录各个deque块的首地址。Map是deque的中心部件，将先于deque块，依照deque元素的个数计算出deque块数，作为Map块的数据项数，创建出Map块。以后，每创建一个deque块，都将deque块的首地址存入Map的相应数据项中。

\3. 什么是优先队列（当时我回答说优先队列可以用堆实现，面试官就问了第4个问题）

优先队列队首元素一定是当前队列中优先级最高的一个

优先队列可以用堆实现

\4. 堆是用最大堆还是最小堆实现优先队列，为什么？

默认是用最大堆实现优先队列（priority_queue<int, vector<int>, less<int> >默认衍生自vector,数字大的优先级越高）

\5. 如果返回堆中最大的元素，要怎么做？

取堆顶元素，如果要取完后要删除，则把最后一个元素移至第一个元素，并将size自减1，然后从堆顶元素自上向下进行整堆

\6. 如果堆中某元素的序号是5，那他两个自孩子的序号分别是多少？

10、11

\7. 说一下快排的时间复杂度

平均复杂度O(nlogn),最坏情况下O(n^2),最好情况下O(nlogn)

\8. 什么样的情况是快排的最坏情况，举个例子

元素均有序是快排的最坏情况

\9. 如何解决快排的的最坏情况（我说的随机打乱）

选择划分元的时候随机进行选择

\10. 说说随机打乱的具体实现

对于0号位元素，随机0-n

对于1号位元素，在1-n中随机一个

对于2号位元素，在2-n中随机一个





12、一串数只出现一次，给定一个输入，让返回所有数对，数对中的两个数之和等于输入。我考虑了1min回答两种思路，第一种快排后两边向中间遍历，大了右边-1，小了左边+1, O(nlogn)的复杂度，然后就是说不排序就和冒泡一样遍历，O(n2)的复杂度。

13、问了游戏排行榜的数据结构应该怎么设计

我先说只取前几名的话堆排序，如果不是前几名的话要看查询多还是改动多，然后说目前只能想到BST。然后又聊会说可以先分组，再排序，就和Query 的select一样，最后join就可以了。后来上网上看了下，网上答案是桶排序和红黑树，虽然自己回答的不精确，不过看来思路还是差不多的。

14、要求我写快排，基本上就是说下思路就可以了，没什么难度。

15、数据库B+树（不了解B+树，扯了扯红黑树）

16、给你一个表（数据很大），有用户名和数据，如何快速检索某条数据

对索引排序+二分查找，对索引建表，在新表里可以用hash、分区等操作(B+树)

17、对数据压缩熟悉不（不熟悉，实习的时候直接调用导师接口，面试官就没接着问）



18、只有大小写英文字母的文本文档，数据量很大，如何压缩表示（因为我说了不懂数据压缩，就出了一个相关问题）

哈夫曼编码+详细实现过程，还可以对重复出现的字母加下标，对重复出现的子串编码（后面两种方法针对可能的具体问题，主要还是哈夫曼编码

19、游戏中，地图很大，英雄的技能释放半径和英雄的坐标已知，如何知道每个英雄的技能范围内的对手（维护一个以技能半径为阈值的大根堆，范围内的入堆，范围外的出堆，面试官不太满意，说不够全面，说只给出了一个环节的方法）

20、一个数组，把所有奇数排在偶数前面，且保证奇数和奇数相对位置不变，偶数和偶数相对位置不变

再用一个数组

21、检测npc之间的距离

22、Hash的知识。（hash的构建与冲突处理。）

1）构建：a直接定址法b除留余数法c数字分析法d平方取中法e折叠法

2）冲突处理：a.开放定址法（线性探测、平方探测、再散列）b拉链法

23、hash冲突，怎么解决（散链表，双重hash，等等）

24、图的搜索有哪几种方式？广搜要怎么做？需要什么额外空间吗

DFS和BFS，其中BFS需要开辟队列内存，DFS需要栈。

25、给定一个迷宫，部分坐标是无法通过的，求某两点间最短路径？（广搜+并查集）

从起点到终点的最短路径其实就是一个建立队列的过程：

1）从起点开始，先将其加入队列，设置距离为0；

2）从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1；

3）循环2直到将终点添加到队列中，这说明我们已经找到了路径；

注意到在这个过程中，每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离；

26、简述Dijkstra算法的过程，描述一下A Star算法

A*算法：

1）把起点加入 open list 。

2）重复如下过程：

a.遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。

b.把这个节点移到 close list 。

c.对当前方格的 8 个相邻方格的每一个方格？

◆   如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。

◆   如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。

◆   如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。

d.停止，当你

◆   把终点加入到了 open list 中，此时路径已经找到了，或者

◆   查找终点失败，并且 open list 是空的，此时没有路径。

3）保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。opened_table：采用优先队列实现的小顶堆，用于存放待扩展结点，同时利用F值作为排序指标；

closed_table：采用set（红黑树）实现，便于快速查找格是否存在于closed_table中；

27、找出一个无序数组中大小后K个数据？

类似于快速排序的思想，随机选取一个元素，把所有小于等于这个元素的数据移到左边，所有大于这个元素的数据移动到右边。

如果这个元素成了第K个数，直接返回这个数。如果左边的个数大于K，不管右边的数了，在左边重复上面的过程。如果左边的个数等于T<K,不管左边的数了，重复上面的过程，只是K=K-T-1。平均情况下，第一次划分的时间复杂度是O(N)，第二次就是O(N/2),总共是O(n+n/2+n/4+...)=O(n)

28、Set的底层实现是什么？红黑树是做什么用的？额外开销是多少？

set的底层实现是红黑树。红黑树是一种平衡二叉查找树。a结点是红色或黑色。b根节点是黑色，每个叶子结点都是黑色，c每个红色结点的两个孩子结点都是黑色。d从每个叶子到根的所有路径上不能有两个连续的红色结点。e从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

红黑树和AVL树一样都对插入时间和删除时间以及查找时间提供了最好可能的最坏保障。时间复杂度是O(logn)，需要额外的空间也是O(logn)

29、给定1000亿个数据，要找出其中最大的一个值，内存只有1G？

大文件变小文件，然后每个文件里hash_map统计最大的值，然后再归并排序。

30、给定1000亿个数据，里边有的数据有重复，要求设计一个算法删除重复数据？要求尽量快。

先取模分成小文件，然后每个文件使用hash_map或者trie树。

31、洗牌算法，如何证明算法是随机的

需要随机置乱的n个元素的数组array：
for( i =n-1;i>=1;i--)
(0 =< j <= i)
交换array[i]和array[j]
end
32、100万个32位整数，如何最快找到中位数。能保证每个数是唯一的，如何实现O(N)算法？
这道题是编程之美或编程珠玑上的。
这道题使用位图，需要空间复杂度是512Ｍ。

33、hashmap和treemap

34、linux rwxrwxrwx文件拷贝

35、版本控制，github指令

38、n个球要分成m堆每个堆不能为空，有多少种分发

39、红黑树实现

每次先按BST方法插入数据，每次都将插入节点变红，然后再自下而上调整节点颜色，使其满足红黑树性质

40、堆了解么？怎么删除元素？怎么插入元素？

删除：删除顶元素，将最后一个数据移到第一个，size自减1，然后从第一个节点自上而下进行整堆

41、图的遍历介绍一下

DFS、BFS

42、你看，现在我百度一个ip地址可以查到那个IP的实际省市显地址，现在我给你每个县/村的ip段，要求你实现一下输入查找功能。【大概是问数据库，我完全不会，瞎答了】

43.你看看我们阴阳师手游里面，可以摇绳子【手机给我展示了一下，真的是像绳子不是单摆】，现在我要你来实现一个绳子，要可以摇那种。

44.你看我打开一个谷歌网页，输入一些单词，他下面给我提示了一些可能我需要的选项，比如我输入一个tail出现了balabala。你现在给我实现一下这个功能，会用什么数据结构什么算法呢。

1）Trie是一颗存储多个字符串的树。相邻节点间的边代表一个字符，这样树的每条分支代表一则子串，而树的叶节点则代表完整的字符串。和普通树不同的地方是，相同的字符串前缀共享同一条分支。

2）hashmap统计: 先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可，最终在O(N)的时间复杂度内用Hash表完成了统计。

3）堆排序：借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N’ * O（logK），（N为1000万，N’为300万）。

45、.你说你打过acm比赛，acm比赛主要是用算法数据结构吧，你说说你觉得你遇到过的最巧妙的一个数据结构或者算法题是什么。【我回答了rope，正好面试官没听过，然后给他瞎bb了一番】

46、给你11位电话号码，让你通过电话找名字
47、 给你多个ipv4的区间，每个区间属于一个城市，如0.0.0.1-1.1.1.1属于北京，给你一个ipv4地址，你要输出所属的城市，如1.1.1.0输出北京。区间有可能会重叠，如果询问的ipv4属于多个城市，则输出所有所属城市。
48、平面最近点对。





**计算机网络：**

1、TCP和UDP的区别

2、tcp的可靠性怎么保证（三次握手、四次挥手、确认序列号）

1）检验和

典型的有CRC校验法。在要传输的k比特数据D后添加(n-k)比特冗余位。

2）序列号

通过序列号，可以去重、超时重传、数据有序到达。

3）确认应答

可以确认ACK之前的数据肯定到达了，保证了可靠性。

4）超时重传

发送的数据有可能因为网络拥堵，没有及时到达，发送端没有收到确认，超过计时器，就会进行重发。

发送端有可能收到许多重复确认，累计到一定次数，TCP认为网络或者接收端出现异常，重新发送丢失的数据包。

5）连接管理

通过三次握手四次挥手，也可提高可靠性。

6）流量控制

接收端处理数据的速度是有限的，如果发送端发的太快，接收端缓冲区容易满，会造成丢包以及引起丢包重传。

7）拥塞控制

发送数据的时候，不能刚开始就发送大量的数据，所以在不清楚网络状况的情况下，不能贸然发送大量的数据，有可能加重网络负担，TCP会使用慢启动机制，探探路，所以刚开始的时候，将拥塞窗口设为1，以后是指数增长，当达到阈值的时候，按照线性增长，到达拥塞窗口的最大值后，拥塞窗口重回1。

3、TCP和UDP的区别？分别举例它们的上层协议？

TCP是基于连接的，可靠的，偏向于传输大量数据，速度慢，http，ftp，smtp，telnet使用了tcp；UDP是无连接的，不可靠的，偏向于传输少量数据，速度快，dns,tftp,rip,snmp，rtp,nfs等使用了udp。

4、TCP4层网络层次、3次握手

5、TCP和UDP的知识点。TCP讲三次握手和四次挥手。

（1）三次握手

第一次握手：主机A发送同步报文段（SYN）请求建立连接。

第二次握手：主机B听到连接请求，就将该连接放入内核等待队列当中，并向主机A发送针对SYN的确认ACK，同时主机B也发送自己的请求建立连接（SYN）。

第三次握手：主机A针对**主机B**SYN的确认应答ACK。

（2）四次挥手

第一次挥手：当主机A发送数据完毕后，发送FIN结束报文段。

第二次挥手：主机B收到FIN报文段后，向主机A发送一个确认序号ACK（为了防止在这段时间内，对方重传FIN报文段）。

第三次挥手：主机B准备关闭连接，向主机A发送一个FIN结束报文段。

第四次挥手：主机A收到FIN结束报文段后，进入TIME_WAIT状态。并向主机B发送一个ACK表示连接彻底释放。（如果客户端的确认应答丢失，算上这个丢失报文的时间，再加上服务端重传FIN的时间（重传后客户端重新启动2MSL计时器），2MSL的时间足够使客户端收到重传的FIN报文段。所以客户端不能立即进入CLOSED状态。）

6、网络，dns、https和http，非对称加密和加密比较一下





**操作系统：**

\1.   进程和线程的区别

1）进程是系统分配资源（CPU以外）的基本单位

2）线程是被系统独立调度的基本单位（CPU的分配单位）

\2. 线程间怎么共享资源

线程直接读/写进程数据段（如全局变量）来通信

3、线程使用共享资源会出现什么问题？需要怎么做？

操作系统具有异步性，如果对共享资源的访问不加以约制，一些具有相互制约、相互合作的线程得到的最终结果可能是错的

设置临界区，对临界区资源设置信号量，进行同步和互斥

4、多线程同步方式

1）软件实现方法（皮特森算法（双标志和单标志）：

Pi: flag[i]=true; turn=j; while(flag[j]&&turn==j); ）

2）硬件实现方法（中断屏蔽方法（屏蔽中断/关中断）、硬件指令方法（原子操作））

3）信号量（PV操作）

4）管程（解决临界区分散所带来的管理和控制问题，包括共享结构数据说明、一组操作、设置共享数据初始值语句）

5、如何进行线程同步？在Windows下举例？分用户模式下同步和内核模式下同步 讨论？

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。

内核模式下的方法有：事件，信号量，互斥量。

6、同步机制应遵循的准则

1）空闲让进

2）忙则等待

3）有限等待

4）让权等待

\7. 进程间通信有哪些算法or多进程通信方式

1）共享存储（PV操作对共享空间读写进行同步互斥）

2）消息传递（1直接通信方式，挂在接收进程的消息缓冲队列上2间接通信方式，即信箱）

3）管道通信（管道是连接读进程和写进程通信的共享文件，限制管道大小，缓冲区允许一边写入另一边读出，管道通信是半双工通信）

4）客户机-服务器系统（包括：套接字（socket），远程过程调用和远程方法调用）

8、进程间通信有哪几种方式？在特定环境（比如两个程序需要共享一个文本）下哪种效率最高？Windows下如何进行内存共享？

无名管道，有名管道，信号量，信号，高级管道，消息队列，共享内存，sokect等，共享内存的效率最高，因为它可以直接读写内存，而不需要任何的数据拷贝。windows下主要通过映射机制实现的。共享内存的方式原理就是将一份物理内存映射到不同进程各自的虚拟地址空间中，这样每个进程都可以读取同一份数据，从而实现进程通信。因为是通过内存操作实现通信，因此是一种最高效的数据交换方法。

9、进程和线程的区别、进程如何调度（扯了进程维护线程池，临界区、事务、信号量、信号）

1）先来先服务调度算法

2）短作业优先调度算法

3）优先级调度算法

4）高响应比优先调度算法（响应比=（等待时间+要求服务时间）/要求服务时间）

5）时间片轮转调度算法

6）多级反馈队列调度算法

10、 简单说一下进程间切换发生的事情

1）保存处理机上下文，包括程序计数器和其他寄存器

2）更新PCB信息

3）把PCB移入相应的队列，如就绪、阻塞队列

4）选择另一个进程执行，并更新其PCB

5）更新内存管理的数据结构

6）恢复处理机上下文

7、进程安全如何保证（扯了进程的数据同步和锁的实现

安全状态：能找到一个分配资源的序列让所有进程都顺利完成

11、进程在什么情况下会互锁

多个进程同时占有对方需要的资源而同时请求对方的资源,而它们在得到请求之前不会释放所占有的资源

（1）   系统资源的竞争

（2）   进程推进顺序非法（信号量使用不当，A等B的消息，B等A的消息）

12、互锁怎么解决

1）预防死锁（设置某些限制条件，破坏死锁四个必要条件之一）

2）避免死锁（动态分配资源过程中，用某种方法防止系统进入不安全状态）

3）死锁检测及解除（剥夺资源、撤销进程、进程回退）

13、线程死锁的几个条件是什么？

（1）互斥条件：指线程对所分配的资源进行排他性使用，即在一段时间内某资源只由一个线程占用。

（2）请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3）不可剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺。

（4）循环等待条件：指在发生死锁时，必然存在一个进程资源循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求

14、给定两个线程，A，B两个锁，举个造成死锁的例子？

程序中使用多个互斥量时，如果允许一个线程一直占有第一个互斥量，并且在试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥量的线程也在试图锁住第一个互斥量，这时就会发生死锁。因为两个线程都在相互请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是就产生死锁。如果所有线程总是在对互斥量B加锁之前锁住互斥量A，那么使用这两个互斥量不会产生死锁

15、可能面试官了解到我是系统方向，所以让我解释一个Hello World程序从C到最终运行起来的过程。

基本上就是先编译，得到Symbol, 链接器Resolve Symbol, Printf属于动态链接库里面的内容 所以涉及到GOT和PLT表，然后操作系统开新的进程，Load二进制文件，将控制流跳到程序入口Main函数执行等等。面试官听到动态链接库，又问了我一些动态链接库的内容和进程的地址空间和 内存的映射(基本上就是回答新进程的地址空间只是映射了Kernel代码，不用创建新的，动态链接库也是映射过来可以执行balabala

16、程序有哪几种链接方式？分别说明区别？哪种效率高？如果一个动态库没有.lib和头文件，要怎么使用里面的函数？

1）静态链接：在程序运行之前，先将各个目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开。我们把这种事先进行链接的方式称为静态链接方式。

2）装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。

3）运行时动态链接：这是指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。（便于修改和更新，便于实现对目标模块的共享）

第三种方式效率较高。还可以节省大量的内存空间。

17、***的作用和实现机制，讲了LRU、FIFO和LEU，详细介绍了LRU的三种实现

Cache作用：调节CPU与主存读取速度不一致的矛盾

Cache实现机制：将Cache和主存都分成若干大小相等的块，Cache中存储主存中最活跃的若干块副本

页面调度算法：

最佳置换算法OPT:选择以后不用的页面

最近最久未使用LRU:选择最近最久未使用的页面（堆栈类算法，需要寄存器和栈的硬件支持）

最不经常使用LFU:将一段时间内访问次数最少的页面换出

先进先出FIFO:选择最先装入内存的页面（基于队列）

时钟置换算法CLOCK(NRU):选择最近未用的页面

改进的时钟算法：考虑页面修改问题

18、问了操作系统的调度，页表之类的问题，然后讲了讲缓存算法。（LRU要求讲一下怎么实现）

LRU的实现：

1）用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。

2）利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。

3）利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。

对于第一种方法，需要不停地维护数据项的访问时间戳，另外，在插入数据、删除数据以及访问数据时，时间复杂度都是O(n)。对于第二种方法，链表在定位数据的时候时间复杂度为O(n)。所以在一般使用第三种方式来是实现LRU算法。

19、基址变址寻址

1）相对寻址：PC的内容加上指令格式中的形式地址A而形成操作数的有效地址

2）基址寻址：将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址（基址寄存器内容由操作系统确定，内容不变，形式地址可变，用于分配存储空间）

3）变址寻址：变址寄存器（IX）的内容加上指令格式中的形式地址A，而形成操作数的有效地址（变址寄存器内容可由用户改变，形式地址A不变，用于数组）

20、堆和栈的区别？

（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小64bits的Windows默认1MB

（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

21、静态变量是存放在数据段或者BSS段，是不入栈的

22、mmu虚拟内存映射（MMU负责虚拟地址映射为物理地址）

虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页框，每个页框大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上虚拟内存就是用于物理内存的临时存放的磁盘空间。页文件就是内存页， 物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。

23、Windows提供了3种方法来进行内存管理：

1）虚拟内存，最适合用来管理大型对象或者结构数组；

2）内存映射文件，最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据；

3）内存堆栈，最适合用来管理大量的小对象。

Windows操纵内存可以分两个层面：物理内存和虚拟内存。，

24、虚拟内存组成部分：

1） 页表机制

2） 中断机构

3） 地址变换机构

4） 内存和外存

25、 epoll的文件描述符是否有拷贝过程？

26、 让你设计一个方式实现内核和用户态都没有拷贝 如何实现？